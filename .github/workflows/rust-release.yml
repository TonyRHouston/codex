name: rust-release
on:
  push:
    tags:
    - rust-v*.*.*
  workflow_dispatch: {}
concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: !!bool 'true'
jobs:
  tag-check:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v6
    - uses: dtolnay/rust-toolchain@1.92
    - name: Validate tag matches Cargo.toml version
      shell: bash
      run: "set -euo pipefail\necho \"::group::Tag validation\"\n\n# 1. Must be a tag and match the regex\n[[ \"${GITHUB_REF_TYPE}\" == \"tag\" ]] \\\n  || { echo \"\u274C  Not a tag push\"; exit 1; }\n[[ \"${GITHUB_REF_NAME}\" =~ ^rust-v[0-9]+\\.[0-9]+\\.[0-9]+(-(alpha|beta)(\\.[0-9]+)?)?$ ]] \\\n  || { echo \"\u274C  Tag '${GITHUB_REF_NAME}' doesn't match expected format\"; exit 1; }\n\n# 2. Extract versions\ntag_ver=\"${GITHUB_REF_NAME#rust-v}\"\ncargo_ver=\"$(grep -m1 '^version' codex-rs/Cargo.toml \\\n              | sed -E 's/version *= *\"([^\"]+)\".*/\\1/')\"\n\n# 3. Compare\n[[ \"${tag_ver}\" == \"${cargo_ver}\" ]] \\\n  || { echo \"\u274C  Tag ${tag_ver} \u2260 Cargo.toml ${cargo_ver}\"; exit 1; }\n\necho \"\u2705  Tag and Cargo.toml agree (${tag_ver})\"\necho \"::endgroup::\"\n"
    - name: Verify config schema fixture
      shell: bash
      working-directory: codex-rs
      run: 'set -euo pipefail

        echo "If this fails, run: just write-config-schema to overwrite fixture with intentional changes."

        cargo run -p codex-core --bin codex-write-config-schema

        git diff --exit-code core/config.schema.json

        '
  build:
    needs: tag-check
    name: Build - ${{ matrix.runner }} - ${{ matrix.target }}
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 60
    permissions:
      contents: read
      id-token: write
    defaults:
      run:
        working-directory: codex-rs
    env:
      CODEX_BWRAP_ENABLE_FFI: ${{ contains(matrix.target, 'unknown-linux') && '1' || '0' }}
    strategy:
      fail-fast: !!bool 'false'
      matrix:
        include:
        - runner: macos-15-xlarge
          target: aarch64-apple-darwin
        - runner: macos-15-xlarge
          target: x86_64-apple-darwin
        - runner: ubuntu-24.04
          target: x86_64-unknown-linux-musl
        - runner: ubuntu-24.04
          target: x86_64-unknown-linux-gnu
        - runner: ubuntu-24.04-arm
          target: aarch64-unknown-linux-musl
        - runner: ubuntu-24.04-arm
          target: aarch64-unknown-linux-gnu
        - runner: windows-latest
          target: x86_64-pc-windows-msvc
        - runner: windows-11-arm
          target: aarch64-pc-windows-msvc
    steps:
    - uses: actions/checkout@v6
    - name: Install Linux bwrap build dependencies
      if: ${{ runner.os == 'Linux' }}
      shell: bash
      run: 'set -euo pipefail

        sudo apt-get update -y

        sudo DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends pkg-config libcap-dev

        '
    - name: Install UBSan runtime (musl)
      if: ${{ matrix.target == 'x86_64-unknown-linux-musl' || matrix.target == 'aarch64-unknown-linux-musl' }}
      shell: bash
      run: "set -euo pipefail\nif command -v apt-get >/dev/null 2>&1; then\n  sudo apt-get update -y\n  sudo DEBIAN_FRONTEND=noninteractive apt-get install -y libubsan1\nfi\n"
    - uses: dtolnay/rust-toolchain@1.93
      with:
        targets: ${{ matrix.target }}
    - if: ${{ matrix.target == 'x86_64-unknown-linux-musl' || matrix.target == 'aarch64-unknown-linux-musl'}}
      name: Use hermetic Cargo home (musl)
      shell: bash
      run: 'set -euo pipefail

        cargo_home="${GITHUB_WORKSPACE}/.cargo-home"

        mkdir -p "${cargo_home}/bin"

        echo "CARGO_HOME=${cargo_home}" >> "$GITHUB_ENV"

        echo "${cargo_home}/bin" >> "$GITHUB_PATH"

        : > "${cargo_home}/config.toml"

        '
    - uses: actions/cache@v5
      with:
        path: '~/.cargo/bin/

          ~/.cargo/registry/index/

          ~/.cargo/registry/cache/

          ~/.cargo/git/db/

          ${{ github.workspace }}/.cargo-home/bin/

          ${{ github.workspace }}/.cargo-home/registry/index/

          ${{ github.workspace }}/.cargo-home/registry/cache/

          ${{ github.workspace }}/.cargo-home/git/db/

          ${{ github.workspace }}/codex-rs/target/

          '
        key: cargo-${{ matrix.runner }}-${{ matrix.target }}-release-${{ hashFiles('**/Cargo.lock') }}
    - if: ${{ matrix.target == 'x86_64-unknown-linux-musl' || matrix.target == 'aarch64-unknown-linux-musl'}}
      name: Install Zig
      uses: mlugg/setup-zig@v2
      with:
        version: 0.14.0
    - if: ${{ matrix.target == 'x86_64-unknown-linux-musl' || matrix.target == 'aarch64-unknown-linux-musl'}}
      name: Install musl build tools
      env:
        TARGET: ${{ matrix.target }}
      run: bash "${GITHUB_WORKSPACE}/.github/scripts/install-musl-build-tools.sh"
    - if: ${{ matrix.target == 'x86_64-unknown-linux-musl' || matrix.target == 'aarch64-unknown-linux-musl'}}
      name: Configure rustc UBSan wrapper (musl host)
      shell: bash
      run: "set -euo pipefail\nubsan=\"\"\nif command -v ldconfig >/dev/null 2>&1; then\n  ubsan=\"$(ldconfig -p | grep -m1 'libubsan\\.so\\.1' | sed -E 's/.*=> (.*)$/\\1/')\"\nfi\nwrapper_root=\"${RUNNER_TEMP:-/tmp}\"\nwrapper=\"${wrapper_root}/rustc-ubsan-wrapper\"\ncat > \"${wrapper}\" <<EOF\n#!/usr/bin/env bash\nset -euo pipefail\nif [[ -n \"${ubsan}\" ]]; then\n  export LD_PRELOAD=\"${ubsan}\\${LD_PRELOAD:+:\\${LD_PRELOAD}}\"\nfi\nexec \"\\$1\" \"\\${@:2}\"\nEOF\nchmod +x \"${wrapper}\"\necho \"RUSTC_WRAPPER=${wrapper}\" >> \"$GITHUB_ENV\"\necho \"RUSTC_WORKSPACE_WRAPPER=\" >> \"$GITHUB_ENV\"\n"
    - if: ${{ matrix.target == 'x86_64-unknown-linux-musl' || matrix.target == 'aarch64-unknown-linux-musl'}}
      name: Clear sanitizer flags (musl)
      shell: bash
      run: "set -euo pipefail\n# Clear global Rust flags so host/proc-macro builds don't pull in UBSan.\necho \"RUSTFLAGS=\" >> \"$GITHUB_ENV\"\necho \"CARGO_ENCODED_RUSTFLAGS=\" >> \"$GITHUB_ENV\"\necho \"RUSTDOCFLAGS=\" >> \"$GITHUB_ENV\"\n# Override any runner-level Cargo config rustflags as well.\necho \"CARGO_BUILD_RUSTFLAGS=\" >> \"$GITHUB_ENV\"\necho \"CARGO_TARGET_X86_64_UNKNOWN_LINUX_GNU_RUSTFLAGS=\" >> \"$GITHUB_ENV\"\necho \"CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_RUSTFLAGS=\" >> \"$GITHUB_ENV\"\necho \"CARGO_TARGET_X86_64_UNKNOWN_LINUX_MUSL_RUSTFLAGS=\" >> \"$GITHUB_ENV\"\necho \"CARGO_TARGET_AARCH64_UNKNOWN_LINUX_MUSL_RUSTFLAGS=\" >> \"$GITHUB_ENV\"\n\nsanitize_flags() {\n  local input=\"$1\"\n  input=\"${input//-fsanitize=undefined/}\"\n  input=\"${input//-fno-sanitize-recover=undefined/}\"\n  input=\"${input//-fno-sanitize-trap=undefined/}\"\n  echo \"$input\"\n}\n\ncflags=\"$(sanitize_flags \"${CFLAGS-}\")\"\ncxxflags=\"$(sanitize_flags \"${CXXFLAGS-}\")\"\necho \"CFLAGS=${cflags}\"\
        \ >> \"$GITHUB_ENV\"\necho \"CXXFLAGS=${cxxflags}\" >> \"$GITHUB_ENV\"\n"
    - name: Cargo build
      shell: bash
      run: "if [[ \"${{ contains(matrix.target, 'windows') }}\" == 'true' ]]; then\n  cargo build --target ${{ matrix.target }} --release --bin codex --bin codex-responses-api-proxy --bin codex-windows-sandbox-setup --bin codex-command-runner\nelse\n  cargo build --target ${{ matrix.target }} --release --bin codex --bin codex-responses-api-proxy\nfi\n"
    - if: ${{ contains(matrix.target, 'linux') }}
      name: Cosign Linux artifacts
      uses: ./.github/actions/linux-code-sign
      with:
        target: ${{ matrix.target }}
        artifacts-dir: ${{ github.workspace }}/codex-rs/target/${{ matrix.target }}/release
    - if: ${{ contains(matrix.target, 'windows') }}
      name: Sign Windows binaries with Azure Trusted Signing
      uses: ./.github/actions/windows-code-sign
      with:
        target: ${{ matrix.target }}
        client-id: ${{ secrets.AZURE_TRUSTED_SIGNING_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TRUSTED_SIGNING_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_TRUSTED_SIGNING_SUBSCRIPTION_ID }}
        endpoint: ${{ secrets.AZURE_TRUSTED_SIGNING_ENDPOINT }}
        account-name: ${{ secrets.AZURE_TRUSTED_SIGNING_ACCOUNT_NAME }}
        certificate-profile-name: ${{ secrets.AZURE_TRUSTED_SIGNING_CERTIFICATE_PROFILE_NAME }}
    - if: ${{ runner.os == 'macOS' }}
      name: MacOS code signing (binaries)
      uses: ./.github/actions/macos-code-sign
      with:
        target: ${{ matrix.target }}
        sign-binaries: true
        sign-dmg: false
        apple-certificate: ${{ secrets.APPLE_CERTIFICATE_P12 }}
        apple-certificate-password: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        apple-notarization-key-p8: ${{ secrets.APPLE_NOTARIZATION_KEY_P8 }}
        apple-notarization-key-id: ${{ secrets.APPLE_NOTARIZATION_KEY_ID }}
        apple-notarization-issuer-id: ${{ secrets.APPLE_NOTARIZATION_ISSUER_ID }}
    - if: ${{ runner.os == 'macOS' }}
      name: Build macOS dmg
      shell: bash
      run: "set -euo pipefail\n\ntarget=\"${{ matrix.target }}\"\nrelease_dir=\"target/${target}/release\"\ndmg_root=\"${RUNNER_TEMP}/codex-dmg-root\"\nvolname=\"Codex (${target})\"\ndmg_path=\"${release_dir}/codex-${target}.dmg\"\n\n# The previous \"MacOS code signing (binaries)\" step signs + notarizes the\n# built artifacts in `${release_dir}`. This step packages *those same*\n# signed binaries into a dmg.\ncodex_binary_path=\"${release_dir}/codex\"\nproxy_binary_path=\"${release_dir}/codex-responses-api-proxy\"\n\nrm -rf \"$dmg_root\"\nmkdir -p \"$dmg_root\"\n\nif [[ ! -f \"$codex_binary_path\" ]]; then\n  echo \"Binary $codex_binary_path not found\"\n  exit 1\nfi\nif [[ ! -f \"$proxy_binary_path\" ]]; then\n  echo \"Binary $proxy_binary_path not found\"\n  exit 1\nfi\n\nditto \"$codex_binary_path\" \"${dmg_root}/codex\"\nditto \"$proxy_binary_path\" \"${dmg_root}/codex-responses-api-proxy\"\n\nrm -f \"$dmg_path\"\nhdiutil create \\\n  -volname \"$volname\" \\\n  -srcfolder \"$dmg_root\"\
        \ \\\n  -format UDZO \\\n  -ov \\\n  \"$dmg_path\"\n\nif [[ ! -f \"$dmg_path\" ]]; then\n  echo \"dmg $dmg_path not found after build\"\n  exit 1\nfi\n"
    - if: ${{ runner.os == 'macOS' }}
      name: MacOS code signing (dmg)
      uses: ./.github/actions/macos-code-sign
      with:
        target: ${{ matrix.target }}
        sign-binaries: false
        sign-dmg: true
        apple-certificate: ${{ secrets.APPLE_CERTIFICATE_P12 }}
        apple-certificate-password: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        apple-notarization-key-p8: ${{ secrets.APPLE_NOTARIZATION_KEY_P8 }}
        apple-notarization-key-id: ${{ secrets.APPLE_NOTARIZATION_KEY_ID }}
        apple-notarization-issuer-id: ${{ secrets.APPLE_NOTARIZATION_ISSUER_ID }}
    - name: Stage artifacts
      shell: bash
      run: "dest=\"dist/${{ matrix.target }}\"\nmkdir -p \"$dest\"\n\nif [[ \"${{ matrix.runner }}\" == windows* ]]; then\n  cp target/${{ matrix.target }}/release/codex.exe \"$dest/codex-${{ matrix.target }}.exe\"\n  cp target/${{ matrix.target }}/release/codex-responses-api-proxy.exe \"$dest/codex-responses-api-proxy-${{ matrix.target }}.exe\"\n  cp target/${{ matrix.target }}/release/codex-windows-sandbox-setup.exe \"$dest/codex-windows-sandbox-setup-${{ matrix.target }}.exe\"\n  cp target/${{ matrix.target }}/release/codex-command-runner.exe \"$dest/codex-command-runner-${{ matrix.target }}.exe\"\nelse\n  cp target/${{ matrix.target }}/release/codex \"$dest/codex-${{ matrix.target }}\"\n  cp target/${{ matrix.target }}/release/codex-responses-api-proxy \"$dest/codex-responses-api-proxy-${{ matrix.target }}\"\nfi\n\nif [[ \"${{ matrix.target }}\" == *linux* ]]; then\n  cp target/${{ matrix.target }}/release/codex.sigstore \"$dest/codex-${{ matrix.target }}.sigstore\"\n  cp target/${{\
        \ matrix.target }}/release/codex-responses-api-proxy.sigstore \"$dest/codex-responses-api-proxy-${{ matrix.target }}.sigstore\"\nfi\n\nif [[ \"${{ matrix.target }}\" == *apple-darwin ]]; then\n  cp target/${{ matrix.target }}/release/codex-${{ matrix.target }}.dmg \"$dest/codex-${{ matrix.target }}.dmg\"\nfi\n"
    - if: ${{ matrix.runner == 'windows-11-arm' }}
      name: Install zstd
      shell: powershell
      run: choco install -y zstandard
    - name: Compress artifacts
      shell: bash
      run: "# Path that contains the uncompressed binaries for the current\n# ${{ matrix.target }}\ndest=\"dist/${{ matrix.target }}\"\nrepo_root=$PWD\n\n# We want to ship the raw Windows executables in the GitHub Release\n# in addition to the compressed archives. Keep the originals for\n# Windows targets; remove them elsewhere to limit the number of\n# artifacts that end up in the GitHub Release.\nkeep_originals=false\nif [[ \"${{ matrix.runner }}\" == windows* ]]; then\n  keep_originals=true\nfi\n\n# For compatibility with environments that lack the `zstd` tool we\n# additionally create a `.tar.gz` for all platforms and `.zip` for\n# Windows alongside every single binary that we publish. The end result is:\n#   codex-<target>.zst          (existing)\n#   codex-<target>.tar.gz       (new)\n#   codex-<target>.zip          (only for Windows)\n\n# 1. Produce a .tar.gz for every file in the directory *before* we\n#    run `zstd --rm`, because that flag deletes the original files.\nfor f in\
        \ \"$dest\"/*; do\n  base=\"$(basename \"$f\")\"\n  # Skip files that are already archives (shouldn't happen, but be\n  # safe).\n  if [[ \"$base\" == *.tar.gz || \"$base\" == *.zip || \"$base\" == *.dmg ]]; then\n    continue\n  fi\n\n  # Don't try to compress signature bundles.\n  if [[ \"$base\" == *.sigstore ]]; then\n    continue\n  fi\n\n  # Create per-binary tar.gz\n  tar -C \"$dest\" -czf \"$dest/${base}.tar.gz\" \"$base\"\n\n  # Create zip archive for Windows binaries\n  # Must run from inside the dest dir so 7z won't\n  # embed the directory path inside the zip.\n  if [[ \"${{ matrix.runner }}\" == windows* ]]; then\n    if [[ \"$base\" == \"codex-${{ matrix.target }}.exe\" ]]; then\n      # Bundle the sandbox helper binaries into the main codex zip so\n      # WinGet installs include the required helpers next to codex.exe.\n      # Fall back to the single-binary zip if the helpers are missing\n      # to avoid breaking releases.\n      bundle_dir=\"$(mktemp -d)\"\n   \
        \   runner_src=\"$dest/codex-command-runner-${{ matrix.target }}.exe\"\n      setup_src=\"$dest/codex-windows-sandbox-setup-${{ matrix.target }}.exe\"\n      if [[ -f \"$runner_src\" && -f \"$setup_src\" ]]; then\n        cp \"$dest/$base\" \"$bundle_dir/$base\"\n        cp \"$runner_src\" \"$bundle_dir/codex-command-runner.exe\"\n        cp \"$setup_src\" \"$bundle_dir/codex-windows-sandbox-setup.exe\"\n        # Use an absolute path so bundle zips land in the real dist\n        # dir even when 7z runs from a temp directory.\n        (cd \"$bundle_dir\" && 7z a \"$repo_root/$dest/${base}.zip\" .)\n      else\n        echo \"warning: missing sandbox binaries; falling back to single-binary zip\"\n        echo \"warning: expected $runner_src and $setup_src\"\n        (cd \"$dest\" && 7z a \"${base}.zip\" \"$base\")\n      fi\n      rm -rf \"$bundle_dir\"\n    else\n      (cd \"$dest\" && 7z a \"${base}.zip\" \"$base\")\n    fi\n  fi\n\n  # Also create .zst (existing behaviour) *and*\
        \ remove the original\n  # uncompressed binary to keep the directory small.\n  zstd_args=(-T0 -19)\n  if [[ \"${keep_originals}\" == false ]]; then\n    zstd_args+=(--rm)\n  fi\n  zstd \"${zstd_args[@]}\" \"$dest/$base\"\ndone\n"
    - uses: actions/upload-artifact@v6
      with:
        name: ${{ matrix.target }}
        path: 'codex-rs/dist/${{ matrix.target }}/*

          '
  shell-tool-mcp:
    name: shell-tool-mcp
    needs: tag-check
    uses: ./.github/workflows/shell-tool-mcp.yml
    with:
      release-tag: ${{ github.ref_name }}
      publish: !!bool 'true'
    secrets: inherit
  release:
    needs:
    - build
    - shell-tool-mcp
    name: release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read
    outputs:
      version: ${{ steps.release_name.outputs.name }}
      tag: ${{ github.ref_name }}
      should_publish_npm: ${{ steps.npm_publish_settings.outputs.should_publish }}
      npm_tag: ${{ steps.npm_publish_settings.outputs.npm_tag }}
    steps:
    - name: Checkout repository
      uses: actions/checkout@v6
    - name: Generate release notes from tag commit message
      id: release_notes
      shell: bash
      run: 'set -euo pipefail


        # On tag pushes, GITHUB_SHA may be a tag object for annotated tags;

        # peel it to the underlying commit.

        commit="$(git rev-parse "${GITHUB_SHA}^{commit}")"

        notes_path="${RUNNER_TEMP}/release-notes.md"


        # Use the commit message for the commit the tag points at (not the

        # annotated tag message).

        git log -1 --format=%B "${commit}" > "${notes_path}"

        # Ensure trailing newline so GitHub''s markdown renderer doesn''t

        # occasionally run the last line into subsequent content.

        echo >> "${notes_path}"


        echo "path=${notes_path}" >> "${GITHUB_OUTPUT}"

        '
    - uses: actions/download-artifact@v7
      with:
        path: dist
    - name: List
      run: ls -R dist/
    - name: Delete entries from dist/ that should not go in the release
      run: 'rm -rf dist/shell-tool-mcp*


        ls -R dist/

        '
    - name: Add config schema release asset
      run: 'cp codex-rs/core/config.schema.json dist/config-schema.json

        '
    - name: Define release name
      id: release_name
      run: '# Extract the version from the tag name, which is in the format

        # "rust-v0.1.0".

        version="${GITHUB_REF_NAME#rust-v}"

        echo "name=${version}" >> $GITHUB_OUTPUT

        '
    - name: Determine npm publish settings
      id: npm_publish_settings
      env:
        VERSION: ${{ steps.release_name.outputs.name }}
      run: "set -euo pipefail\nversion=\"${VERSION}\"\n\nif [[ \"${version}\" =~ ^[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n  echo \"should_publish=true\" >> \"$GITHUB_OUTPUT\"\n  echo \"npm_tag=\" >> \"$GITHUB_OUTPUT\"\nelif [[ \"${version}\" =~ ^[0-9]+\\.[0-9]+\\.[0-9]+-alpha\\.[0-9]+$ ]]; then\n  echo \"should_publish=true\" >> \"$GITHUB_OUTPUT\"\n  echo \"npm_tag=alpha\" >> \"$GITHUB_OUTPUT\"\nelse\n  echo \"should_publish=false\" >> \"$GITHUB_OUTPUT\"\n  echo \"npm_tag=\" >> \"$GITHUB_OUTPUT\"\nfi\n"
    - name: Setup pnpm
      uses: pnpm/action-setup@v4
      with:
        run_install: !!bool 'false'
    - name: Setup Node.js for npm packaging
      uses: actions/setup-node@v6
      with:
        node-version: 22
    - name: Install dependencies
      run: pnpm install --frozen-lockfile
    - uses: facebook/install-dotslash@v2
    - name: Stage npm packages
      env:
        GH_TOKEN: ${{ github.token }}
      run: "./scripts/stage_npm_packages.py \\\n  --release-version \"${{ steps.release_name.outputs.name }}\" \\\n  --package codex \\\n  --package codex-responses-api-proxy \\\n  --package codex-sdk\n"
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        name: ${{ steps.release_name.outputs.name }}
        tag_name: ${{ github.ref_name }}
        body_path: ${{ steps.release_notes.outputs.path }}
        files: dist/**
        prerelease: ${{ contains(steps.release_name.outputs.name, '-') }}
    - uses: facebook/dotslash-publish-release@v2
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag: ${{ github.ref_name }}
        config: .github/dotslash-config.json
    - name: Trigger developers.openai.com deploy
      if: ${{ !contains(steps.release_name.outputs.name, '-') }}
      continue-on-error: !!bool 'true'
      env:
        DEV_WEBSITE_VERCEL_DEPLOY_HOOK_URL: ${{ secrets.DEV_WEBSITE_VERCEL_DEPLOY_HOOK_URL }}
      run: "if ! curl -sS -f -o /dev/null -X POST \"$DEV_WEBSITE_VERCEL_DEPLOY_HOOK_URL\"; then\n  echo \"::warning title=developers.openai.com deploy hook failed::Vercel deploy hook POST failed for ${GITHUB_REF_NAME}\"\n  exit 1\nfi\n"
  publish-npm:
    if: ${{ needs.release.outputs.should_publish_npm == 'true' }}
    name: publish-npm
    needs: release
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
    - name: Setup Node.js
      uses: actions/setup-node@v6
      with:
        node-version: 22
        registry-url: https://registry.npmjs.org
        scope: '@openai'
    - name: Update npm
      run: npm install -g npm@latest
    - name: Download npm tarballs from release
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: "set -euo pipefail\nversion=\"${{ needs.release.outputs.version }}\"\ntag=\"${{ needs.release.outputs.tag }}\"\nmkdir -p dist/npm\ngh release download \"$tag\" \\\n  --repo \"${GITHUB_REPOSITORY}\" \\\n  --pattern \"codex-npm-${version}.tgz\" \\\n  --dir dist/npm\ngh release download \"$tag\" \\\n  --repo \"${GITHUB_REPOSITORY}\" \\\n  --pattern \"codex-responses-api-proxy-npm-${version}.tgz\" \\\n  --dir dist/npm\ngh release download \"$tag\" \\\n  --repo \"${GITHUB_REPOSITORY}\" \\\n  --pattern \"codex-sdk-npm-${version}.tgz\" \\\n  --dir dist/npm\n"
    - name: Publish to npm
      env:
        VERSION: ${{ needs.release.outputs.version }}
        NPM_TAG: ${{ needs.release.outputs.npm_tag }}
      run: "set -euo pipefail\ntag_args=()\nif [[ -n \"${NPM_TAG}\" ]]; then\n  tag_args+=(--tag \"${NPM_TAG}\")\nfi\n\ntarballs=(\n  \"codex-npm-${VERSION}.tgz\"\n  \"codex-responses-api-proxy-npm-${VERSION}.tgz\"\n  \"codex-sdk-npm-${VERSION}.tgz\"\n)\n\nfor tarball in \"${tarballs[@]}\"; do\n  npm publish \"${GITHUB_WORKSPACE}/dist/npm/${tarball}\" \"${tag_args[@]}\"\ndone\n"
  update-branch:
    name: Update latest-alpha-cli branch
    permissions:
      contents: write
    needs: release
    runs-on: ubuntu-latest
    steps:
    - name: Update latest-alpha-cli branch
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: "set -euo pipefail\ngh api \\\n  repos/${GITHUB_REPOSITORY}/git/refs/heads/latest-alpha-cli \\\n  -X PATCH \\\n  -f sha=\"${GITHUB_SHA}\" \\\n  -F force=true\n"
